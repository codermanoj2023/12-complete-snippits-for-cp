{
    "min of a subset": {
        "prefix": "MinSegmentTree",
        "body": [
            "template <class T>",
            "class MinSegmentTree",
            "{",
            "private:",
            "    const T DEFAULT = std::numeric_limits<T>().max();",
            "",
            "    int len;",
            "    vector<T> tree;",
            "",
            "    T combine(const T &a, const T &b) { return std::min(a, b); }",
            "",
            "    void build(const vector<T> &arr, int node, int start, int end)",
            "    {",
            "        if (start == end)",
            "        {",
            "            tree[node] = arr[start];",
            "            return;",
            "        }",
            "        int mid = start + (end - start) / 2;",
            "        build(arr, 2 * node + 1, start, mid);",
            "        build(arr, 2 * node + 2, mid + 1, end);",
            "        tree[node] = combine(tree[2 * node + 1], tree[2 * node + 2]);",
            "    }",
            "",
            "    void updateTree(int i, T val, int node, int start, int end)",
            "    {",
            "        if (i < start || i > end)",
            "            return;",
            "        if (start == end)",
            "        {",
            "            tree[node] = val;",
            "            return;",
            "        }",
            "        int mid = start + (end - start) / 2;",
            "        updateTree(i, val, 2 * node + 1, start, mid);",
            "        updateTree(i, val, 2 * node + 2, mid + 1, end);",
            "        tree[node] = combine(tree[2 * node + 1], tree[2 * node + 2]);",
            "    }",
            "",
            "    T range_min(int left, int right, int node, int start, int end)",
            "    {",
            "        if (end < left || right < start)",
            "        {",
            "            return DEFAULT;",
            "        }",
            "        if (left <= start && end <= right)",
            "        {",
            "            return tree[node];",
            "        }",
            "        int mid = start + (end - start) / 2;",
            "        T left_res = range_min(left, right, 2 * node + 1, start, mid);",
            "        T right_res = range_min(left, right, 2 * node + 2, mid + 1, end);",
            "        return combine(left_res, right_res);",
            "    }",
            "",
            "public:",
            "    MinSegmentTree(int len) : len(len) { tree = vector<T>(len * 4, DEFAULT); };",
            "",
            "    MinSegmentTree(const vector<T> &arr) : len(arr.size())",
            "    {",
            "        tree = vector<T>(len * 4, DEFAULT);",
            "        build(arr, 0, 0, len - 1);",
            "    }",
            "",
            "    void update(int i, T val) { updateTree(i, val, 0, 0, len - 1); }",
            "",
            "    T query(int left, int right) { return range_min(left, right, 0, 0, len - 1); }",
            "};",
            ""
        ],
        "description": "min of a subset"
    }
}